<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaming Hub - Premium Arcade Experience</title>
    <style>
        /* ===== CSS VARIABLES ===== */
        :root {
            /* Primary Colors */
            --neon-blue: #00ffff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --neon-orange: #ff6600;
            --neon-purple: #9d00ff;
            --neon-red: #ff0055;
            --neon-yellow: #ffff00;
            
            /* Background */
            --bg-dark: #0a0a1a;
            --bg-darker: #050510;
            --bg-card: rgba(20, 20, 40, 0.8);
            
            /* UI */
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        /* ===== GLOBAL STYLES ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, var(--bg-darker) 0%, var(--bg-dark) 50%, #001a33 100%);
            color: var(--neon-blue);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* ===== HUB STYLES ===== */
        #hubContainer {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .hub-header {
            text-align: center;
            padding: 40px 20px;
        }

        .hub-header h1 {
            font-size: 4em;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue), 0 0 60px var(--neon-blue);
            animation: glow 2s ease-in-out infinite alternate;
        }

        .hub-header p {
            font-size: 1.2em;
            opacity: 0.8;
            letter-spacing: 0.2em;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px var(--neon-blue), 0 0 40px var(--neon-blue), 0 0 60px var(--neon-blue); }
            to { text-shadow: 0 0 30px var(--neon-blue), 0 0 60px var(--neon-blue), 0 0 90px var(--neon-blue); }
        }

        /* ===== GAME GRID ===== */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 30px;
            padding: 20px;
        }

        .game-card {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 2px solid var(--glass-border);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .game-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.5s;
        }

        .game-card:hover::before {
            left: 100%;
        }

        .game-card:hover {
            transform: translateY(-10px) scale(1.02);
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
            border-color: var(--neon-blue);
        }

        .game-icon {
            font-size: 4em;
            text-align: center;
            margin: 20px 0;
            filter: drop-shadow(0 0 20px currentColor);
        }

        .game-title {
            font-size: 1.8em;
            text-align: center;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .game-description {
            text-align: center;
            opacity: 0.7;
            margin-bottom: 15px;
            font-size: 0.9em;
        }

        .game-meta {
            display: flex;
            justify-content: space-around;
            margin: 15px 0;
            font-size: 0.85em;
        }

        .game-meta span {
            opacity: 0.8;
        }

        .play-button {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            border-radius: 5px;
        }

        .play-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: var(--neon-blue);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
            z-index: -1;
        }

        .play-button:hover::before {
            width: 400px;
            height: 400px;
        }

        .play-button:hover {
            color: #000;
            box-shadow: 0 0 20px var(--neon-blue);
        }

        /* ===== GAME CONTAINER ===== */
        #gameContainer {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: var(--bg-dark);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #gameContainer.active {
            display: flex;
        }

        .game-header {
            width: 100%;
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--neon-blue);
        }

        .back-button {
            padding: 10px 20px;
            font-size: 1.2em;
            background: transparent;
            border: 2px solid var(--neon-orange);
            color: var(--neon-orange);
            cursor: pointer;
            transition: all 0.3s;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
        }

        .back-button:hover {
            background: var(--neon-orange);
            color: #000;
            box-shadow: 0 0 20px var(--neon-orange);
        }

        .game-title-display {
            font-size: 2em;
            text-shadow: 0 0 20px currentColor;
        }

        .game-score {
            font-size: 1.5em;
        }

        .canvas-wrapper {
            position: relative;
            margin: 20px;
            border: 3px solid var(--neon-blue);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        canvas {
            display: block;
            background: #000a1a;
        }

        /* ===== CONTROLS INFO ===== */
        .controls-info {
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border-top: 2px solid var(--neon-blue);
            width: 100%;
            text-align: center;
            opacity: 0.7;
            font-size: 0.9em;
        }

        /* ===== RESPONSIVE ===== */
        @media (max-width: 768px) {
            .hub-header h1 {
                font-size: 2.5em;
            }
            
            .games-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .game-header {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }
        }

        /* ===== UTILITY CLASSES ===== */
        .hidden {
            display: none !important;
        }

        /* ===== FPS COUNTER ===== */
        #fpsCounter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: var(--neon-green);
            padding: 10px;
            border: 1px solid var(--neon-green);
            font-family: monospace;
            font-size: 14px;
            z-index: 2000;
            display: none;
        }
    </style>
</head>
<body>
    <!-- FPS Counter -->
    <div id="fpsCounter">FPS: 60</div>

    <!-- Hub Container -->
    <div id="hubContainer">
        <div class="hub-header">
            <h1>üéÆ GAMING HUB üéÆ</h1>
            <p>Premium Arcade Experience</p>
        </div>

        <div class="games-grid" id="gamesGrid">
            <!-- Game cards will be generated here -->
        </div>
    </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <div class="game-header">
            <button class="back-button" onclick="backToHub()">‚Üê Zur√ºck</button>
            <div class="game-title-display" id="currentGameTitle"></div>
            <div class="game-score" id="currentGameScore">Score: 0</div>
        </div>
        
        <div class="canvas-wrapper">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>
        
        <div class="controls-info" id="controlsInfo"></div>
    </div>

    <script>
        // ===== GAME ENGINE =====
        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.running = false;
                this.currentGame = null;
                this.fps = 60;
                this.frameTime = 1000 / this.fps;
                this.lastFrameTime = 0;
                this.deltaTime = 0;
            }

            start(game) {
                this.currentGame = game;
                this.running = true;
                this.lastFrameTime = performance.now();
                this.loop();
            }

            stop() {
                this.running = false;
                this.currentGame = null;
            }

            loop(timestamp = 0) {
                if (!this.running) return;

                this.deltaTime = timestamp - this.lastFrameTime;
                
                if (this.deltaTime >= this.frameTime) {
                    this.update();
                    this.render();
                    this.lastFrameTime = timestamp - (this.deltaTime % this.frameTime);
                }

                requestAnimationFrame((t) => this.loop(t));
            }

            update() {
                if (this.currentGame && this.currentGame.update) {
                    this.currentGame.update(this.deltaTime);
                }
            }

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.currentGame && this.currentGame.render) {
                    this.currentGame.render(this.ctx);
                }
            }
        }

        const gameEngine = new GameEngine();

        // ===== GAMES CONFIGURATION =====
        const games = [
            {
                id: 'tron',
                title: 'TRON',
                icon: 'üèçÔ∏è',
                description: 'Classic light cycles battle',
                difficulty: '‚≠ê‚≠ê‚≠ê',
                players: '1-2 Players',
                category: 'Arcade',
                color: '#00ffff',
                controls: 'Player 1: Arrow Keys | Player 2: WASD | Pause: P'
            },
            {
                id: 'snake',
                title: 'SNAKE',
                icon: 'üêç',
                description: 'Modernized snake with power-ups',
                difficulty: '‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Arcade',
                color: '#00ff00',
                controls: 'Arrow Keys to move | Collect food to grow | Avoid walls and yourself'
            },
            {
                id: 'tetris',
                title: 'TETRIS',
                icon: 'üß±',
                description: 'Ultimate block stacking experience',
                difficulty: '‚≠ê‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Puzzle',
                color: '#ff00ff',
                controls: 'Arrow Keys: Move | Space: Rotate | Down: Fast Drop'
            },
            {
                id: 'pacman',
                title: 'PAC-MAN',
                icon: 'üëª',
                description: 'Hunt ghosts in the maze',
                difficulty: '‚≠ê‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Arcade',
                color: '#ffff00',
                controls: 'Arrow Keys to move | Eat all dots | Power pellets let you eat ghosts'
            },
            {
                id: 'pong',
                title: 'PONG',
                icon: 'üèì',
                description: 'Revolutionary table tennis',
                difficulty: '‚≠ê‚≠ê',
                players: '1-2 Players',
                category: 'Arcade',
                color: '#ffffff',
                controls: 'W/S or Arrow Up/Down | First to 11 wins'
            },
            {
                id: 'breakout',
                title: 'BREAKOUT',
                icon: 'üéØ',
                description: 'Extreme brick breaking action',
                difficulty: '‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Arcade',
                color: '#ff6600',
                controls: 'Arrow Keys or Mouse to move paddle | Break all bricks'
            },
            {
                id: 'invaders',
                title: 'SPACE INVADERS',
                icon: 'üëæ',
                description: 'Defend Earth from alien invasion',
                difficulty: '‚≠ê‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Action',
                color: '#00ff00',
                controls: 'Arrow Keys to move | Space to shoot | Destroy all invaders'
            },
            {
                id: 'asteroids',
                title: 'ASTEROIDS',
                icon: '‚òÑÔ∏è',
                description: 'Navigate through asteroid field',
                difficulty: '‚≠ê‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Action',
                color: '#00ffff',
                controls: 'Arrow Keys: Rotate & Thrust | Space: Shoot'
            },
            {
                id: 'flappy',
                title: 'FLAPPY BIRD',
                icon: 'üê¶',
                description: 'Ultra challenging flying game',
                difficulty: '‚≠ê‚≠ê‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Arcade',
                color: '#ffaa00',
                controls: 'Space or Click to flap | Avoid pipes'
            },
            {
                id: 'match3',
                title: 'MATCH-3',
                icon: 'üíé',
                description: 'Match colorful jewels',
                difficulty: '‚≠ê‚≠ê',
                players: '1 Player',
                category: 'Puzzle',
                color: '#ff00ff',
                controls: 'Click to swap adjacent gems | Match 3 or more'
            }
        ];

        // ===== RENDER GAME CARDS =====
        function renderGameCards() {
            const grid = document.getElementById('gamesGrid');
            grid.innerHTML = games.map(game => `
                <div class="game-card" onclick="startGame('${game.id}')" style="border-color: ${game.color}">
                    <div class="game-icon" style="color: ${game.color}">${game.icon}</div>
                    <div class="game-title" style="color: ${game.color}">${game.title}</div>
                    <div class="game-description">${game.description}</div>
                    <div class="game-meta">
                        <span>${game.difficulty}</span>
                        <span>${game.players}</span>
                        <span>${game.category}</span>
                    </div>
                    <button class="play-button" style="border-color: ${game.color}; color: ${game.color}">
                        PLAY
                    </button>
                </div>
            `).join('');
        }

        // ===== NAVIGATION =====
        function startGame(gameId) {
            const game = games.find(g => g.id === gameId);
            if (!game) return;

            document.getElementById('hubContainer').classList.add('hidden');
            document.getElementById('gameContainer').classList.add('active');
            document.getElementById('currentGameTitle').textContent = game.title;
            document.getElementById('currentGameTitle').style.color = game.color;
            document.getElementById('controlsInfo').textContent = game.controls;
            
            // Initialize and start the specific game
            initializeGame(gameId);
        }

        function backToHub() {
            gameEngine.stop();
            document.getElementById('hubContainer').classList.remove('hidden');
            document.getElementById('gameContainer').classList.remove('active');
            document.getElementById('currentGameScore').textContent = 'Score: 0';
        }

        // ===== GAME IMPLEMENTATIONS =====
        
        // Simple game template
        class SimpleGame {
            constructor(name) {
                this.name = name;
                this.score = 0;
            }

            update(deltaTime) {
                // Game update logic
            }

            render(ctx) {
                // Game render logic
                ctx.fillStyle = '#00ffff';
                ctx.font = '30px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(this.name + ' - Coming Soon!', 400, 300);
                ctx.font = '20px Courier New';
                ctx.fillText('This game is being developed...', 400, 350);
            }
        }

        // SNAKE GAME
        class SnakeGame {
            constructor() {
                this.gridSize = 20;
                this.snake = [{x: 10, y: 10}];
                this.direction = {x: 1, y: 0};
                this.food = this.generateFood();
                this.score = 0;
                this.speed = 100;
                this.lastUpdate = 0;
                this.gameOver = false;
                
                document.addEventListener('keydown', (e) => this.handleInput(e));
            }

            handleInput(e) {
                if (this.gameOver) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (this.direction.y === 0) this.direction = {x: 0, y: -1};
                        break;
                    case 'ArrowDown':
                        if (this.direction.y === 0) this.direction = {x: 0, y: 1};
                        break;
                    case 'ArrowLeft':
                        if (this.direction.x === 0) this.direction = {x: -1, y: 0};
                        break;
                    case 'ArrowRight':
                        if (this.direction.x === 0) this.direction = {x: 1, y: 0};
                        break;
                }
            }

            generateFood() {
                return {
                    x: Math.floor(Math.random() * (800 / this.gridSize)),
                    y: Math.floor(Math.random() * (600 / this.gridSize))
                };
            }

            update(deltaTime) {
                if (this.gameOver) return;

                this.lastUpdate += deltaTime;
                if (this.lastUpdate < this.speed) return;
                this.lastUpdate = 0;

                const head = {...this.snake[0]};
                head.x += this.direction.x;
                head.y += this.direction.y;

                // Check wall collision
                if (head.x < 0 || head.x >= 800/this.gridSize || head.y < 0 || head.y >= 600/this.gridSize) {
                    this.gameOver = true;
                    return;
                }

                // Check self collision
                if (this.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                    this.gameOver = true;
                    return;
                }

                this.snake.unshift(head);

                // Check food collision
                if (head.x === this.food.x && head.y === this.food.y) {
                    this.score += 10;
                    this.food = this.generateFood();
                    document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                } else {
                    this.snake.pop();
                }
            }

            render(ctx) {
                // Draw snake
                ctx.fillStyle = '#00ff00';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ff00';
                this.snake.forEach((segment, index) => {
                    const alpha = 1 - (index / this.snake.length) * 0.5;
                    ctx.globalAlpha = alpha;
                    ctx.fillRect(
                        segment.x * this.gridSize,
                        segment.y * this.gridSize,
                        this.gridSize - 2,
                        this.gridSize - 2
                    );
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;

                // Draw food
                ctx.fillStyle = '#ff0055';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff0055';
                ctx.beginPath();
                ctx.arc(
                    this.food.x * this.gridSize + this.gridSize/2,
                    this.food.y * this.gridSize + this.gridSize/2,
                    this.gridSize/2 - 2,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                ctx.shadowBlur = 0;

                // Game over
                if (this.gameOver) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '40px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 400, 300);
                    ctx.font = '20px Courier New';
                    ctx.fillText('Press SPACE to restart', 400, 340);
                }
            }
        }

        // TETRIS GAME (simplified)
        class TetrisGame {
            constructor() {
                this.blockSize = 30;
                this.cols = 10;
                this.rows = 20;
                this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
                this.currentPiece = this.generatePiece();
                this.score = 0;
                this.speed = 500;
                this.lastUpdate = 0;
                this.gameOver = false;
                
                document.addEventListener('keydown', (e) => this.handleInput(e));
            }

            generatePiece() {
                const pieces = [
                    [[1,1,1,1]], // I
                    [[1,1],[1,1]], // O
                    [[1,1,1],[0,1,0]], // T
                    [[1,1,0],[0,1,1]], // S
                    [[0,1,1],[1,1,0]] // Z
                ];
                const piece = pieces[Math.floor(Math.random() * pieces.length)];
                return {
                    shape: piece,
                    x: Math.floor(this.cols / 2) - 1,
                    y: 0,
                    color: ['#00ffff', '#ffff00', '#ff00ff', '#ff0000', '#00ff00'][Math.floor(Math.random() * 5)]
                };
            }

            handleInput(e) {
                if (this.gameOver) return;
                
                switch(e.key) {
                    case 'ArrowLeft':
                        this.movePiece(-1, 0);
                        break;
                    case 'ArrowRight':
                        this.movePiece(1, 0);
                        break;
                    case 'ArrowDown':
                        this.movePiece(0, 1);
                        break;
                    case ' ':
                        this.rotatePiece();
                        break;
                }
            }

            movePiece(dx, dy) {
                this.currentPiece.x += dx;
                this.currentPiece.y += dy;
                
                if (this.checkCollision()) {
                    this.currentPiece.x -= dx;
                    this.currentPiece.y -= dy;
                    
                    if (dy > 0) {
                        this.lockPiece();
                    }
                }
            }

            rotatePiece() {
                const rotated = this.currentPiece.shape[0].map((_, i) =>
                    this.currentPiece.shape.map(row => row[i]).reverse()
                );
                const oldShape = this.currentPiece.shape;
                this.currentPiece.shape = rotated;
                
                if (this.checkCollision()) {
                    this.currentPiece.shape = oldShape;
                }
            }

            checkCollision() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const newX = this.currentPiece.x + x;
                            const newY = this.currentPiece.y + y;
                            
                            if (newX < 0 || newX >= this.cols || newY >= this.rows) {
                                return true;
                            }
                            
                            if (newY >= 0 && this.board[newY][newX]) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            lockPiece() {
                for (let y = 0; y < this.currentPiece.shape.length; y++) {
                    for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                        if (this.currentPiece.shape[y][x]) {
                            const boardY = this.currentPiece.y + y;
                            const boardX = this.currentPiece.x + x;
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = this.currentPiece.color;
                            }
                        }
                    }
                }
                
                this.clearLines();
                this.currentPiece = this.generatePiece();
                
                if (this.checkCollision()) {
                    this.gameOver = true;
                }
            }

            clearLines() {
                let linesCleared = 0;
                for (let y = this.rows - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(this.cols).fill(0));
                        linesCleared++;
                        y++;
                    }
                }
                
                if (linesCleared > 0) {
                    this.score += linesCleared * 100;
                    document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                }
            }

            update(deltaTime) {
                if (this.gameOver) return;
                
                this.lastUpdate += deltaTime;
                if (this.lastUpdate >= this.speed) {
                    this.movePiece(0, 1);
                    this.lastUpdate = 0;
                }
            }

            render(ctx) {
                const offsetX = (800 - this.cols * this.blockSize) / 2;
                const offsetY = 0;
                
                // Draw board
                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        if (this.board[y][x]) {
                            ctx.fillStyle = this.board[y][x];
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = this.board[y][x];
                            ctx.fillRect(
                                offsetX + x * this.blockSize + 1,
                                offsetY + y * this.blockSize + 1,
                                this.blockSize - 2,
                                this.blockSize - 2
                            );
                        }
                    }
                }
                ctx.shadowBlur = 0;
                
                // Draw current piece
                if (!this.gameOver) {
                    ctx.fillStyle = this.currentPiece.color;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.currentPiece.color;
                    for (let y = 0; y < this.currentPiece.shape.length; y++) {
                        for (let x = 0; x < this.currentPiece.shape[y].length; x++) {
                            if (this.currentPiece.shape[y][x]) {
                                ctx.fillRect(
                                    offsetX + (this.currentPiece.x + x) * this.blockSize + 1,
                                    offsetY + (this.currentPiece.y + y) * this.blockSize + 1,
                                    this.blockSize - 2,
                                    this.blockSize - 2
                                );
                            }
                        }
                    }
                    ctx.shadowBlur = 0;
                }
                
                // Draw grid
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let x = 0; x <= this.cols; x++) {
                    ctx.beginPath();
                    ctx.moveTo(offsetX + x * this.blockSize, offsetY);
                    ctx.lineTo(offsetX + x * this.blockSize, offsetY + this.rows * this.blockSize);
                    ctx.stroke();
                }
                for (let y = 0; y <= this.rows; y++) {
                    ctx.beginPath();
                    ctx.moveTo(offsetX, offsetY + y * this.blockSize);
                    ctx.lineTo(offsetX + this.cols * this.blockSize, offsetY + y * this.blockSize);
                    ctx.stroke();
                }
                
                if (this.gameOver) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '40px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 400, 300);
                }
            }
        }

        // PONG GAME
        class PongGame {
            constructor() {
                this.paddleWidth = 10;
                this.paddleHeight = 80;
                this.ballSize = 10;
                this.player1 = { x: 20, y: 260, score: 0, dy: 0 };
                this.player2 = { x: 770, y: 260, score: 0, dy: 0 };
                this.ball = { x: 400, y: 300, dx: 4, dy: 3 };
                this.keys = {};
                
                document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                document.addEventListener('keyup', (e) => this.keys[e.key] = false);
            }

            update(deltaTime) {
                // Player controls
                if (this.keys['w'] || this.keys['W']) this.player1.y = Math.max(0, this.player1.y - 5);
                if (this.keys['s'] || this.keys['S']) this.player1.y = Math.min(520, this.player1.y + 5);
                if (this.keys['ArrowUp']) this.player2.y = Math.max(0, this.player2.y - 5);
                if (this.keys['ArrowDown']) this.player2.y = Math.min(520, this.player2.y + 5);

                // Ball movement
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                // Ball collision with top/bottom
                if (this.ball.y <= 0 || this.ball.y >= 590) this.ball.dy *= -1;

                // Ball collision with paddles
                if (this.ball.x <= 30 && this.ball.y >= this.player1.y && this.ball.y <= this.player1.y + 80) {
                    this.ball.dx = Math.abs(this.ball.dx);
                    this.ball.dy += (Math.random() - 0.5) * 2;
                }
                if (this.ball.x >= 760 && this.ball.y >= this.player2.y && this.ball.y <= this.player2.y + 80) {
                    this.ball.dx = -Math.abs(this.ball.dx);
                    this.ball.dy += (Math.random() - 0.5) * 2;
                }

                // Scoring
                if (this.ball.x < 0) {
                    this.player2.score++;
                    this.resetBall();
                }
                if (this.ball.x > 800) {
                    this.player1.score++;
                    this.resetBall();
                }
                
                document.getElementById('currentGameScore').textContent = 
                    `P1: ${this.player1.score} | P2: ${this.player2.score}`;
            }

            resetBall() {
                this.ball = { x: 400, y: 300, dx: (Math.random() > 0.5 ? 4 : -4), dy: (Math.random() - 0.5) * 6 };
            }

            render(ctx) {
                // Draw paddles
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(this.player1.x, this.player1.y, this.paddleWidth, this.paddleHeight);
                
                ctx.fillStyle = '#ff6600';
                ctx.shadowColor = '#ff6600';
                ctx.fillRect(this.player2.x, this.player2.y, this.paddleWidth, this.paddleHeight);

                // Draw ball
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ballSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw center line
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(400, 0);
                ctx.lineTo(400, 600);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // BREAKOUT GAME
        class BreakoutGame {
            constructor() {
                this.paddleWidth = 100;
                this.paddleHeight = 15;
                this.paddle = { x: 350, y: 550 };
                this.ball = { x: 400, y: 300, dx: 3, dy: -3, size: 8 };
                this.bricks = [];
                this.score = 0;
                this.keys = {};
                
                // Create bricks
                const colors = ['#ff0055', '#ff6600', '#ffff00', '#00ff00', '#00ffff', '#0066ff', '#9d00ff'];
                for (let row = 0; row < 6; row++) {
                    for (let col = 0; col < 10; col++) {
                        this.bricks.push({
                            x: col * 80 + 5,
                            y: row * 30 + 50,
                            width: 75,
                            height: 25,
                            color: colors[row % colors.length],
                            alive: true
                        });
                    }
                }
                
                document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                document.addEventListener('keyup', (e) => this.keys[e.key] = false);
            }

            update(deltaTime) {
                // Paddle movement
                if (this.keys['ArrowLeft']) this.paddle.x = Math.max(0, this.paddle.x - 6);
                if (this.keys['ArrowRight']) this.paddle.x = Math.min(700, this.paddle.x + 6);

                // Ball movement
                this.ball.x += this.ball.dx;
                this.ball.y += this.ball.dy;

                // Wall collisions
                if (this.ball.x <= 0 || this.ball.x >= 800) this.ball.dx *= -1;
                if (this.ball.y <= 0) this.ball.dy *= -1;

                // Paddle collision
                if (this.ball.y + this.ball.size >= this.paddle.y &&
                    this.ball.x >= this.paddle.x &&
                    this.ball.x <= this.paddle.x + this.paddleWidth) {
                    this.ball.dy = -Math.abs(this.ball.dy);
                    // Add spin based on where ball hits paddle
                    const hitPos = (this.ball.x - this.paddle.x) / this.paddleWidth;
                    this.ball.dx = (hitPos - 0.5) * 6;
                }

                // Brick collisions
                this.bricks.forEach(brick => {
                    if (brick.alive &&
                        this.ball.x >= brick.x && this.ball.x <= brick.x + brick.width &&
                        this.ball.y >= brick.y && this.ball.y <= brick.y + brick.height) {
                        brick.alive = false;
                        this.ball.dy *= -1;
                        this.score += 10;
                        document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                    }
                });

                // Game over
                if (this.ball.y > 600) {
                    this.ball = { x: 400, y: 300, dx: 3, dy: -3, size: 8 };
                }
            }

            render(ctx) {
                // Draw bricks
                this.bricks.forEach(brick => {
                    if (brick.alive) {
                        ctx.fillStyle = brick.color;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = brick.color;
                        ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    }
                });

                // Draw paddle
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(this.paddle.x, this.paddle.y, this.paddleWidth, this.paddleHeight);

                // Draw ball
                ctx.fillStyle = '#ffffff';
                ctx.shadowColor = '#ffffff';
                ctx.beginPath();
                ctx.arc(this.ball.x, this.ball.y, this.ball.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // SPACE INVADERS GAME
        class SpaceInvadersGame {
            constructor() {
                this.player = { x: 375, y: 550, width: 50, height: 30, speed: 5 };
                this.bullets = [];
                this.aliens = [];
                this.alienBullets = [];
                this.score = 0;
                this.keys = {};
                this.alienDirection = 1;
                this.alienSpeed = 0.5;
                
                // Create aliens
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 8; col++) {
                        this.aliens.push({
                            x: col * 80 + 100,
                            y: row * 60 + 50,
                            width: 40,
                            height: 30,
                            alive: true
                        });
                    }
                }
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === ' ') {
                        this.bullets.push({ x: this.player.x + 25, y: this.player.y, speed: 7 });
                    }
                });
                document.addEventListener('keyup', (e) => this.keys[e.key] = false);
            }

            update(deltaTime) {
                // Player movement
                if (this.keys['ArrowLeft']) this.player.x = Math.max(0, this.player.x - this.player.speed);
                if (this.keys['ArrowRight']) this.player.x = Math.min(750, this.player.x + this.player.speed);

                // Move aliens
                let moveDown = false;
                this.aliens.forEach(alien => {
                    if (alien.alive) {
                        alien.x += this.alienDirection * this.alienSpeed;
                        if (alien.x <= 0 || alien.x >= 760) moveDown = true;
                    }
                });
                
                if (moveDown) {
                    this.alienDirection *= -1;
                    this.aliens.forEach(alien => {
                        if (alien.alive) alien.y += 20;
                    });
                }

                // Move bullets
                this.bullets = this.bullets.filter(b => {
                    b.y -= b.speed;
                    return b.y > 0;
                });

                // Alien shooting (random)
                if (Math.random() < 0.01) {
                    const aliveAliens = this.aliens.filter(a => a.alive);
                    if (aliveAliens.length > 0) {
                        const shooter = aliveAliens[Math.floor(Math.random() * aliveAliens.length)];
                        this.alienBullets.push({ x: shooter.x + 20, y: shooter.y + 30, speed: 3 });
                    }
                }

                this.alienBullets = this.alienBullets.filter(b => {
                    b.y += b.speed;
                    return b.y < 600;
                });

                // Collision detection
                this.bullets.forEach(bullet => {
                    this.aliens.forEach(alien => {
                        if (alien.alive &&
                            bullet.x >= alien.x && bullet.x <= alien.x + alien.width &&
                            bullet.y >= alien.y && bullet.y <= alien.y + alien.height) {
                            alien.alive = false;
                            bullet.y = -10;
                            this.score += 100;
                            document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                        }
                    });
                });
            }

            render(ctx) {
                // Draw player
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                ctx.beginPath();
                ctx.moveTo(this.player.x + 25, this.player.y - 10);
                ctx.lineTo(this.player.x + 15, this.player.y);
                ctx.lineTo(this.player.x + 35, this.player.y);
                ctx.closePath();
                ctx.fill();

                // Draw aliens
                ctx.fillStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                this.aliens.forEach(alien => {
                    if (alien.alive) {
                        ctx.fillRect(alien.x, alien.y, alien.width, alien.height);
                    }
                });

                // Draw bullets
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                this.bullets.forEach(b => {
                    ctx.fillRect(b.x, b.y, 3, 10);
                });

                ctx.fillStyle = '#ff0055';
                ctx.shadowColor = '#ff0055';
                this.alienBullets.forEach(b => {
                    ctx.fillRect(b.x, b.y, 3, 10);
                });
                
                ctx.shadowBlur = 0;
            }
        }

        // FLAPPY BIRD GAME
        class FlappyBirdGame {
            constructor() {
                this.bird = { x: 100, y: 300, velocity: 0, size: 20 };
                this.gravity = 0.5;
                this.jump = -10;
                this.pipes = [];
                this.score = 0;
                this.gameOver = false;
                this.pipeGap = 150;
                this.pipeWidth = 60;
                this.frameCount = 0;
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ' && !this.gameOver) {
                        this.bird.velocity = this.jump;
                    }
                });
            }

            update(deltaTime) {
                if (this.gameOver) return;

                // Bird physics
                this.bird.velocity += this.gravity;
                this.bird.y += this.bird.velocity;

                // Ground/ceiling collision
                if (this.bird.y <= 0 || this.bird.y >= 580) {
                    this.gameOver = true;
                }

                // Generate pipes
                this.frameCount++;
                if (this.frameCount % 100 === 0) {
                    const gapY = Math.random() * 200 + 100;
                    this.pipes.push({
                        x: 800,
                        topHeight: gapY,
                        bottomY: gapY + this.pipeGap,
                        scored: false
                    });
                }

                // Move pipes
                this.pipes.forEach(pipe => {
                    pipe.x -= 3;
                    
                    // Score
                    if (!pipe.scored && pipe.x < this.bird.x) {
                        pipe.scored = true;
                        this.score++;
                        document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                    }

                    // Collision
                    if (pipe.x < this.bird.x + this.bird.size &&
                        pipe.x + this.pipeWidth > this.bird.x) {
                        if (this.bird.y < pipe.topHeight || this.bird.y + this.bird.size > pipe.bottomY) {
                            this.gameOver = true;
                        }
                    }
                });

                // Remove off-screen pipes
                this.pipes = this.pipes.filter(p => p.x > -this.pipeWidth);
            }

            render(ctx) {
                // Draw bird
                ctx.fillStyle = '#ffaa00';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffaa00';
                ctx.beginPath();
                ctx.arc(this.bird.x, this.bird.y, this.bird.size, 0, Math.PI * 2);
                ctx.fill();

                // Draw pipes
                ctx.fillStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                this.pipes.forEach(pipe => {
                    // Top pipe
                    ctx.fillRect(pipe.x, 0, this.pipeWidth, pipe.topHeight);
                    // Bottom pipe
                    ctx.fillRect(pipe.x, pipe.bottomY, this.pipeWidth, 600 - pipe.bottomY);
                });
                
                ctx.shadowBlur = 0;

                if (this.gameOver) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '40px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 400, 300);
                }
            }
        }

        // TRON GAME (Enhanced)
        class TronGame {
            constructor() {
                this.gridSize = 10;
                this.player1 = {
                    x: 100, y: 300, dx: this.gridSize, dy: 0,
                    trail: [{x: 100, y: 300}],
                    color: '#00ffff',
                    alive: true
                };
                this.player2 = {
                    x: 700, y: 300, dx: -this.gridSize, dy: 0,
                    trail: [{x: 700, y: 300}],
                    color: '#ff6600',
                    alive: true
                };
                this.keys = {};
                this.lastUpdate = 0;
                this.speed = 80;
                this.gameOver = false;
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === 'ArrowUp' && this.player1.dy === 0) {
                        this.player1.dx = 0; this.player1.dy = -this.gridSize;
                    } else if (e.key === 'ArrowDown' && this.player1.dy === 0) {
                        this.player1.dx = 0; this.player1.dy = this.gridSize;
                    } else if (e.key === 'ArrowLeft' && this.player1.dx === 0) {
                        this.player1.dx = -this.gridSize; this.player1.dy = 0;
                    } else if (e.key === 'ArrowRight' && this.player1.dx === 0) {
                        this.player1.dx = this.gridSize; this.player1.dy = 0;
                    }
                    // Player 2
                    if ((e.key === 'w' || e.key === 'W') && this.player2.dy === 0) {
                        this.player2.dx = 0; this.player2.dy = -this.gridSize;
                    } else if ((e.key === 's' || e.key === 'S') && this.player2.dy === 0) {
                        this.player2.dx = 0; this.player2.dy = this.gridSize;
                    } else if ((e.key === 'a' || e.key === 'A') && this.player2.dx === 0) {
                        this.player2.dx = -this.gridSize; this.player2.dy = 0;
                    } else if ((e.key === 'd' || e.key === 'D') && this.player2.dx === 0) {
                        this.player2.dx = this.gridSize; this.player2.dy = 0;
                    }
                });
            }

            checkCollision(player) {
                // Wall collision
                if (player.x < 0 || player.x >= 800 || player.y < 0 || player.y >= 600) return true;
                
                // Trail collision
                for (let p of this.player1.trail) {
                    if (player.x === p.x && player.y === p.y) return true;
                }
                for (let p of this.player2.trail) {
                    if (player.x === p.x && player.y === p.y) return true;
                }
                return false;
            }

            update(deltaTime) {
                if (this.gameOver) return;

                this.lastUpdate += deltaTime;
                if (this.lastUpdate < this.speed) return;
                this.lastUpdate = 0;

                // Move players
                this.player1.x += this.player1.dx;
                this.player1.y += this.player1.dy;
                this.player2.x += this.player2.dx;
                this.player2.y += this.player2.dy;

                // Check collisions
                const p1Collision = this.checkCollision(this.player1);
                const p2Collision = this.checkCollision(this.player2);

                if (p1Collision && p2Collision) {
                    this.gameOver = true;
                } else if (p1Collision) {
                    this.player1.alive = false;
                    this.gameOver = true;
                } else if (p2Collision) {
                    this.player2.alive = false;
                    this.gameOver = true;
                }

                // Add to trails
                this.player1.trail.push({x: this.player1.x, y: this.player1.y});
                this.player2.trail.push({x: this.player2.x, y: this.player2.y});
            }

            render(ctx) {
                // Draw trails
                ctx.shadowBlur = 15;
                
                // Player 1 trail
                ctx.strokeStyle = this.player1.color;
                ctx.shadowColor = this.player1.color;
                ctx.lineWidth = 5;
                ctx.beginPath();
                if (this.player1.trail.length > 0) {
                    ctx.moveTo(this.player1.trail[0].x + 5, this.player1.trail[0].y + 5);
                    for (let i = 1; i < this.player1.trail.length; i++) {
                        ctx.lineTo(this.player1.trail[i].x + 5, this.player1.trail[i].y + 5);
                    }
                    ctx.stroke();
                }

                // Player 2 trail
                ctx.strokeStyle = this.player2.color;
                ctx.shadowColor = this.player2.color;
                ctx.beginPath();
                if (this.player2.trail.length > 0) {
                    ctx.moveTo(this.player2.trail[0].x + 5, this.player2.trail[0].y + 5);
                    for (let i = 1; i < this.player2.trail.length; i++) {
                        ctx.lineTo(this.player2.trail[i].x + 5, this.player2.trail[i].y + 5);
                    }
                    ctx.stroke();
                }

                // Draw player heads
                if (this.player1.alive) {
                    ctx.fillStyle = this.player1.color;
                    ctx.shadowColor = this.player1.color;
                    ctx.shadowBlur = 20;
                    ctx.fillRect(this.player1.x, this.player1.y, this.gridSize, this.gridSize);
                }
                
                if (this.player2.alive) {
                    ctx.fillStyle = this.player2.color;
                    ctx.shadowColor = this.player2.color;
                    ctx.fillRect(this.player2.x, this.player2.y, this.gridSize, this.gridSize);
                }
                
                ctx.shadowBlur = 0;

                if (this.gameOver) {
                    ctx.fillStyle = '#ff0000';
                    ctx.font = '40px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', 400, 300);
                    const winner = this.player1.alive ? 'Player 1' : 'Player 2';
                    ctx.font = '25px Courier New';
                    ctx.fillText(winner + ' Wins!', 400, 350);
                }
            }
        }

        // PAC-MAN GAME (Simplified)
        class PacManGame {
            constructor() {
                this.pacman = { x: 400, y: 300, size: 15, direction: 0, mouthOpen: 0 };
                this.ghosts = [
                    { x: 200, y: 200, color: '#ff0000', dx: 2, dy: 0 },
                    { x: 600, y: 200, color: '#ffb8ff', dx: -2, dy: 0 },
                    { x: 200, y: 400, color: '#00ffff', dx: 0, dy: 2 },
                    { x: 600, y: 400, color: '#ffb852', dx: 0, dy: -2 }
                ];
                this.dots = [];
                this.score = 0;
                this.speed = 3;
                this.keys = {};
                
                // Generate dots
                for (let x = 50; x < 800; x += 40) {
                    for (let y = 50; y < 600; y += 40) {
                        this.dots.push({ x, y, eaten: false });
                    }
                }
                
                document.addEventListener('keydown', (e) => this.keys[e.key] = true);
                document.addEventListener('keyup', (e) => this.keys[e.key] = false);
            }

            update(deltaTime) {
                // Pac-Man movement
                if (this.keys['ArrowUp']) { this.pacman.direction = -Math.PI / 2; this.pacman.y -= this.speed; }
                if (this.keys['ArrowDown']) { this.pacman.direction = Math.PI / 2; this.pacman.y += this.speed; }
                if (this.keys['ArrowLeft']) { this.pacman.direction = Math.PI; this.pacman.x -= this.speed; }
                if (this.keys['ArrowRight']) { this.pacman.direction = 0; this.pacman.x += this.speed; }
                
                this.pacman.mouthOpen = (this.pacman.mouthOpen + 0.1) % (Math.PI * 2);

                // Keep in bounds
                this.pacman.x = Math.max(20, Math.min(780, this.pacman.x));
                this.pacman.y = Math.max(20, Math.min(580, this.pacman.y));

                // Eat dots
                this.dots.forEach(dot => {
                    if (!dot.eaten) {
                        const dist = Math.hypot(this.pacman.x - dot.x, this.pacman.y - dot.y);
                        if (dist < 20) {
                            dot.eaten = true;
                            this.score += 10;
                            document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                        }
                    }
                });

                // Move ghosts
                this.ghosts.forEach(ghost => {
                    ghost.x += ghost.dx;
                    ghost.y += ghost.dy;
                    
                    // Bounce off walls
                    if (ghost.x < 30 || ghost.x > 770) ghost.dx *= -1;
                    if (ghost.y < 30 || ghost.y > 570) ghost.dy *= -1;
                    
                    // Random direction change
                    if (Math.random() < 0.01) {
                        const dirs = [{dx: 2, dy: 0}, {dx: -2, dy: 0}, {dx: 0, dy: 2}, {dx: 0, dy: -2}];
                        const dir = dirs[Math.floor(Math.random() * dirs.length)];
                        ghost.dx = dir.dx;
                        ghost.dy = dir.dy;
                    }
                });
            }

            render(ctx) {
                // Draw dots
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 5;
                ctx.shadowColor = '#ffff00';
                this.dots.forEach(dot => {
                    if (!dot.eaten) {
                        ctx.beginPath();
                        ctx.arc(dot.x, dot.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                // Draw Pac-Man
                ctx.fillStyle = '#ffff00';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                const mouth = Math.abs(Math.sin(this.pacman.mouthOpen)) * 0.4;
                ctx.arc(this.pacman.x, this.pacman.y, this.pacman.size, 
                    this.pacman.direction + mouth, this.pacman.direction + Math.PI * 2 - mouth);
                ctx.lineTo(this.pacman.x, this.pacman.y);
                ctx.closePath();
                ctx.fill();

                // Draw ghosts
                this.ghosts.forEach(ghost => {
                    ctx.fillStyle = ghost.color;
                    ctx.shadowColor = ghost.color;
                    ctx.beginPath();
                    ctx.arc(ghost.x, ghost.y, 15, Math.PI, 0);
                    ctx.lineTo(ghost.x + 15, ghost.y + 20);
                    ctx.lineTo(ghost.x + 10, ghost.y + 15);
                    ctx.lineTo(ghost.x + 5, ghost.y + 20);
                    ctx.lineTo(ghost.x, ghost.y + 15);
                    ctx.lineTo(ghost.x - 5, ghost.y + 20);
                    ctx.lineTo(ghost.x - 10, ghost.y + 15);
                    ctx.lineTo(ghost.x - 15, ghost.y + 20);
                    ctx.lineTo(ghost.x - 15, ghost.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Eyes
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 0;
                    ctx.fillRect(ghost.x - 7, ghost.y - 5, 5, 8);
                    ctx.fillRect(ghost.x + 2, ghost.y - 5, 5, 8);
                    ctx.fillStyle = '#0000ff';
                    ctx.fillRect(ghost.x - 5, ghost.y - 3, 3, 4);
                    ctx.fillRect(ghost.x + 4, ghost.y - 3, 3, 4);
                });
                
                ctx.shadowBlur = 0;
            }
        }

        // ASTEROIDS GAME
        class AsteroidsGame {
            constructor() {
                this.ship = { x: 400, y: 300, angle: 0, vx: 0, vy: 0, size: 15 };
                this.asteroids = [];
                this.bullets = [];
                this.score = 0;
                this.keys = {};
                
                // Create initial asteroids
                for (let i = 0; i < 5; i++) {
                    this.createAsteroid(Math.random() * 800, Math.random() * 600, 40);
                }
                
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === ' ') {
                        this.bullets.push({
                            x: this.ship.x + Math.cos(this.ship.angle) * 15,
                            y: this.ship.y + Math.sin(this.ship.angle) * 15,
                            vx: Math.cos(this.ship.angle) * 8,
                            vy: Math.sin(this.ship.angle) * 8
                        });
                    }
                });
                document.addEventListener('keyup', (e) => this.keys[e.key] = false);
            }

            createAsteroid(x, y, size) {
                this.asteroids.push({
                    x, y, size,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.1
                });
            }

            update(deltaTime) {
                // Ship controls
                if (this.keys['ArrowLeft']) this.ship.angle -= 0.1;
                if (this.keys['ArrowRight']) this.ship.angle += 0.1;
                if (this.keys['ArrowUp']) {
                    this.ship.vx += Math.cos(this.ship.angle) * 0.2;
                    this.ship.vy += Math.sin(this.ship.angle) * 0.2;
                }

                // Apply friction
                this.ship.vx *= 0.99;
                this.ship.vy *= 0.99;

                // Move ship
                this.ship.x += this.ship.vx;
                this.ship.y += this.ship.vy;

                // Wrap around screen
                if (this.ship.x < 0) this.ship.x = 800;
                if (this.ship.x > 800) this.ship.x = 0;
                if (this.ship.y < 0) this.ship.y = 600;
                if (this.ship.y > 600) this.ship.y = 0;

                // Move asteroids
                this.asteroids.forEach(asteroid => {
                    asteroid.x += asteroid.vx;
                    asteroid.y += asteroid.vy;
                    asteroid.rotation += asteroid.rotationSpeed;
                    
                    // Wrap around
                    if (asteroid.x < -50) asteroid.x = 850;
                    if (asteroid.x > 850) asteroid.x = -50;
                    if (asteroid.y < -50) asteroid.y = 650;
                    if (asteroid.y > 650) asteroid.y = -50;
                });

                // Move bullets
                this.bullets = this.bullets.filter(bullet => {
                    bullet.x += bullet.vx;
                    bullet.y += bullet.vy;
                    return bullet.x > 0 && bullet.x < 800 && bullet.y > 0 && bullet.y < 600;
                });

                // Collision detection
                this.bullets.forEach(bullet => {
                    this.asteroids.forEach((asteroid, index) => {
                        const dist = Math.hypot(bullet.x - asteroid.x, bullet.y - asteroid.y);
                        if (dist < asteroid.size) {
                            this.asteroids.splice(index, 1);
                            bullet.x = -100; // Remove bullet
                            this.score += 100;
                            document.getElementById('currentGameScore').textContent = 'Score: ' + this.score;
                            
                            // Split asteroid
                            if (asteroid.size > 15) {
                                this.createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2);
                                this.createAsteroid(asteroid.x, asteroid.y, asteroid.size / 2);
                            }
                        }
                    });
                });
            }

            render(ctx) {
                // Draw ship
                ctx.save();
                ctx.translate(this.ship.x, this.ship.y);
                ctx.rotate(this.ship.angle);
                ctx.strokeStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.ship.size, 0);
                ctx.lineTo(-this.ship.size, -this.ship.size / 2);
                ctx.lineTo(-this.ship.size / 2, 0);
                ctx.lineTo(-this.ship.size, this.ship.size / 2);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();

                // Draw asteroids
                ctx.strokeStyle = '#888888';
                ctx.shadowColor = '#888888';
                this.asteroids.forEach(asteroid => {
                    ctx.save();
                    ctx.translate(asteroid.x, asteroid.y);
                    ctx.rotate(asteroid.rotation);
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const radius = asteroid.size * (0.8 + Math.random() * 0.4);
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                });

                // Draw bullets
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                this.bullets.forEach(bullet => {
                    ctx.beginPath();
                    ctx.arc(bullet.x, bullet.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                ctx.shadowBlur = 0;
            }
        }

        // Initialize specific game
        function initializeGame(gameId) {
            let game;
            
            switch(gameId) {
                case 'tron':
                    game = new TronGame();
                    break;
                case 'snake':
                    game = new SnakeGame();
                    break;
                case 'tetris':
                    game = new TetrisGame();
                    break;
                case 'pacman':
                    game = new PacManGame();
                    break;
                case 'pong':
                    game = new PongGame();
                    break;
                case 'breakout':
                    game = new BreakoutGame();
                    break;
                case 'invaders':
                    game = new SpaceInvadersGame();
                    break;
                case 'asteroids':
                    game = new AsteroidsGame();
                    break;
                case 'flappy':
                    game = new FlappyBirdGame();
                    break;
                default:
                    game = new SimpleGame(games.find(g => g.id === gameId).title);
            }
            
            gameEngine.start(game);
        }

        // ===== INITIALIZATION =====
        window.addEventListener('load', () => {
            renderGameCards();
        });

        // ESC key to go back
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('gameContainer').classList.contains('active')) {
                backToHub();
            }
        });
    </script>
</body>
</html>