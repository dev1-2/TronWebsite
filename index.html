<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRON - Light Cycles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background:  linear-gradient(to bottom, #000000, #001a33);
            color: #00ffff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            text-align: center;
            position: relative;
        }

        h1 {
            font-size: 4em;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            margin-bottom:  20px;
            text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { text-shadow: 0 0 20px #00ffff, 0 0 40px #00ffff, 0 0 60px #00ffff; }
            to { text-shadow: 0 0 30px #00ffff, 0 0 60px #00ffff, 0 0 90px #00ffff; }
        }

        #menu, #gameOver {
            background: rgba(0, 26, 51, 0.9);
            border: 3px solid #00ffff;
            border-radius: 10px;
            padding: 40px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        . btn {
            display: inline-block;
            margin: 15px;
            padding: 15px 40px;
            font-size:  1.5em;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.3s;
            letter-spacing: 0.1em;
        }

        .btn:hover {
            background: #00ffff;
            color:  #000;
            box-shadow: 0 0 20px #00ffff;
            transform: scale(1.05);
        }

        . btn. player2 {
            border-color: #ff6600;
            color: #ff6600;
        }

        .btn.player2:hover {
            background:  #ff6600;
            color: #000;
            box-shadow: 0 0 20px #ff6600;
        }

        canvas {
            border: 3px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            display: none;
            background: #000a1a;
        }

        #scoreBoard {
            display: none;
            margin-top: 20px;
            font-size: 1.5em;
            letter-spacing: 0.1em;
        }

        . score {
            display: inline-block;
            margin: 0 30px;
            padding: 10px 20px;
            border: 2px solid;
            border-radius: 5px;
        }

        .score.player1 {
            border-color:  #00ffff;
            color: #00ffff;
            text-shadow: 0 0 10px #00ffff;
        }

        .score.player2 {
            border-color: #ff6600;
            color: #ff6600;
            text-shadow: 0 0 10px #ff6600;
        }

        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        #winner {
            font-size: 2em;
            margin-bottom: 20px;
            text-transform: uppercase;
        }

        . hidden {
            display: none ! important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <h1>TRON</h1>
        
        <div id="menu">
            <h2 style="margin-bottom: 30px;">Wähle deinen Modus</h2>
            <button class="btn" onclick="startGame('single')">Single Player</button>
            <button class="btn player2" onclick="startGame('multi')">2 Player</button>
            <div style="margin-top: 30px; font-size: 0.9em; opacity: 0.7;">
                <p>Spieler 1: Pfeiltasten ↑ ↓ ← →</p>
                <p>Spieler 2: WASD</p>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div id="scoreBoard">
            <div class="score player1">Spieler 1: <span id="score1">0</span></div>
            <div class="score player2">Spieler 2: <span id="score2">0</span></div>
        </div>

        <div id="gameOver">
            <h2 id="winner"></h2>
            <button class="btn" onclick="restart()">Nochmal spielen</button>
            <button class="btn player2" onclick="backToMenu()">Hauptmenü</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const gameOverDiv = document.getElementById('gameOver');
        const scoreBoard = document.getElementById('scoreBoard');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const winnerEl = document.getElementById('winner');

        let gameMode = '';
        let gameRunning = false;
        let animationId;

        const gridSize = 10;
        const speed = 100;

        let player1 = {
            x: 100,
            y: 300,
            dx: gridSize,
            dy: 0,
            trail: [],
            color: '#00ffff',
            score: 0
        };

        let player2 = {
            x: 700,
            y: 300,
            dx: -gridSize,
            dy: 0,
            trail: [],
            color:  '#ff6600',
            score: 0
        };

        let lastUpdateTime = 0;

        function startGame(mode) {
            gameMode = mode;
            menu.classList.add('hidden');
            canvas.style.display = 'block';
            scoreBoard.style.display = 'block';
            gameOverDiv. style.display = 'none';
            
            resetPlayers();
            gameRunning = true;
            lastUpdateTime = Date.now();
            gameLoop();
        }

        function resetPlayers() {
            player1 = {
                x:  100,
                y: 300,
                dx: gridSize,
                dy: 0,
                trail: [{x: 100, y: 300}],
                color: '#00ffff',
                score:  player1.score
            };

            player2 = {
                x: 700,
                y:  300,
                dx: -gridSize,
                dy: 0,
                trail: [{x: 700, y: 300}],
                color: '#ff6600',
                score: player2.score
            };

            updateScores();
        }

        function updateScores() {
            score1El.textContent = player1.score;
            score2El. textContent = player2.score;
        }

        document.addEventListener('keydown', (e) => {
            if (! gameRunning) return;

            // Spieler 1 - Pfeiltasten
            if (e.key === 'ArrowUp' && player1.dy === 0) {
                player1.dx = 0;
                player1.dy = -gridSize;
            } else if (e.key === 'ArrowDown' && player1.dy === 0) {
                player1.dx = 0;
                player1.dy = gridSize;
            } else if (e. key === 'ArrowLeft' && player1.dx === 0) {
                player1.dx = -gridSize;
                player1.dy = 0;
            } else if (e. key === 'ArrowRight' && player1.dx === 0) {
                player1.dx = gridSize;
                player1.dy = 0;
            }

            // Spieler 2 - WASD (nur im 2-Player Modus)
            if (gameMode === 'multi') {
                if (e.key === 'w' && player2.dy === 0) {
                    player2.dx = 0;
                    player2.dy = -gridSize;
                } else if (e.key === 's' && player2.dy === 0) {
                    player2.dx = 0;
                    player2.dy = gridSize;
                } else if (e.key === 'a' && player2.dx === 0) {
                    player2.dx = -gridSize;
                    player2.dy = 0;
                } else if (e.key === 'd' && player2.dx === 0) {
                    player2.dx = gridSize;
                    player2.dy = 0;
                }
            }
        });

        function aiMove() {
            const directions = [
                {dx: 0, dy: -gridSize}, // oben
                {dx: 0, dy: gridSize},  // unten
                {dx: -gridSize, dy: 0}, // links
                {dx: gridSize, dy: 0}   // rechts
            ];

            // Filtere die aktuelle Rückwärtsrichtung aus
            const validDirections = directions.filter(dir => {
                return !(dir.dx === -player2.dx && dir.dy === -player2.dy);
            });

            // Bewerte jede Richtung
            let bestDirection = null;
            let bestScore = -Infinity;

            for (let dir of validDirections) {
                const newX = player2.x + dir.dx;
                const newY = player2.y + dir. dy;

                if (checkCollision(newX, newY, player2)) {
                    continue; // Diese Richtung führt zu Kollision
                }

                // Berechne Distanz zu Spieler 1 (weiter weg ist besser)
                const distToPlayer1 = Math.sqrt(
                    Math.pow(newX - player1.x, 2) + Math.pow(newY - player1.y, 2)
                );

                // Berechne freien Raum in dieser Richtung
                let freeSpace = 0;
                let testX = newX;
                let testY = newY;
                while (! checkCollision(testX, testY, player2) && freeSpace < 50) {
                    testX += dir.dx;
                    testY += dir.dy;
                    freeSpace++;
                }

                const score = freeSpace * 10 + distToPlayer1 * 0.1;

                if (score > bestScore) {
                    bestScore = score;
                    bestDirection = dir;
                }
            }

            if (bestDirection) {
                player2.dx = bestDirection.dx;
                player2.dy = bestDirection.dy;
            }
        }

        function checkCollision(x, y, player) {
            // Wand-Kollision
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return true;
            }

            // Kollision mit Spieler 1 Trail
            for (let segment of player1.trail) {
                if (segment.x === x && segment.y === y) {
                    return true;
                }
            }

            // Kollision mit Spieler 2 Trail
            for (let segment of player2.trail) {
                if (segment.x === x && segment.y === y) {
                    return true;
                }
            }

            return false;
        }

        function update() {
            // KI-Bewegung im Single Player Modus
            if (gameMode === 'single') {
                aiMove();
            }

            // Bewege Spieler
            player1.x += player1.dx;
            player1.y += player1.dy;
            player2.x += player2.dx;
            player2.y += player2.dy;

            // Füge neue Position zum Trail hinzu
            player1.trail.push({x: player1.x, y: player1.y});
            player2.trail.push({x: player2.x, y: player2.y});

            // Prüfe Kollisionen
            const p1Collision = checkCollision(player1.x, player1.y, player1);
            const p2Collision = checkCollision(player2.x, player2.y, player2);

            if (p1Collision && p2Collision) {
                endGame('Unentschieden! ');
            } else if (p1Collision) {
                player2.score++;
                updateScores();
                endGame(gameMode === 'single' ? 'KI gewinnt!' : 'Spieler 2 gewinnt! ');
            } else if (p2Collision) {
                player1.score++;
                updateScores();
                endGame('Spieler 1 gewinnt!');
            }
        }

        function draw() {
            // Lösche Canvas
            ctx.fillStyle = '#000a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Zeichne Grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += gridSize * 5) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas. height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += gridSize * 5) {
                ctx. beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            // Zeichne Spieler 1 Trail mit Glow
            ctx.shadowBlur = 15;
            ctx.shadowColor = player1.color;
            ctx.strokeStyle = player1.color;
            ctx.lineWidth = 4;
            ctx.beginPath();
            for (let i = 0; i < player1.trail.length - 1; i++) {
                ctx.moveTo(player1.trail[i].x + gridSize/2, player1.trail[i].y + gridSize/2);
                ctx.lineTo(player1.trail[i+1]. x + gridSize/2, player1.trail[i+1]. y + gridSize/2);
            }
            ctx.stroke();

            // Zeichne Spieler 1 Kopf
            ctx.fillStyle = player1.color;
            ctx. fillRect(player1.x, player1.y, gridSize, gridSize);

            // Zeichne Spieler 2 Trail mit Glow
            ctx.shadowColor = player2.color;
            ctx.strokeStyle = player2.color;
            ctx.beginPath();
            for (let i = 0; i < player2.trail.length - 1; i++) {
                ctx.moveTo(player2.trail[i].x + gridSize/2, player2.trail[i].y + gridSize/2);
                ctx.lineTo(player2.trail[i+1].x + gridSize/2, player2.trail[i+1].y + gridSize/2);
            }
            ctx.stroke();

            // Zeichne Spieler 2 Kopf
            ctx.fillStyle = player2.color;
            ctx.fillRect(player2.x, player2.y, gridSize, gridSize);

            ctx.shadowBlur = 0;
        }

        function gameLoop() {
            if (!gameRunning) return;

            const currentTime = Date.now();
            if (currentTime - lastUpdateTime >= speed) {
                update();
                lastUpdateTime = currentTime;
            }

            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        function endGame(message) {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            winnerEl.textContent = message;
            gameOverDiv.style.display = 'block';
        }

        function restart() {
            gameOverDiv.style.display = 'none';
            resetPlayers();
            gameRunning = true;
            lastUpdateTime = Date. now();
            gameLoop();
        }

        function backToMenu() {
            gameOverDiv.style.display = 'none';
            canvas.style.display = 'none';
            scoreBoard.style.display = 'none';
            menu.classList. remove('hidden');
            player1.score = 0;
            player2.score = 0;
            updateScores();
        }
    </script>
</body>
</html>
